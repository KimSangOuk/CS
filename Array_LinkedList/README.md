흔히 쓰는 자료를 담는 리스트에는 두 가지 종류가 있다.

하나가 배열(Array)이고 다른 하나가 연결 리스트(Linked List)이다.

그렇다면 배열은 뭐고 연결 리스트는 무엇일까?

## 개념에 대해 먼저 알아보자

배열이란 연속된 메모리 공간이 있을 때, 같은 타입의 요소를 연속적으로 저장하는 자료구조이다.

예를 들자면 쉽게 상자가 연속적으로 줄지어 놓여 있다고 생각하면 이해하기 쉽다.

이러한 배열은 다음과 같은 특징을 가진다.

- 인덱스 접근 시, `O(1)`로 즉시 접근 가능
- 선언 시 크기를 할당하면 런타임 시에는 변경이 불가능
- 메모리 사용 면에서 보면 따로 포인터가 필요 없기에 추가 비용이 발생하지 않는다. 즉 오버헤드가 없다.
- 삽입, 삭제 시, 시간 복잡도가 `O(n)`  이다. 하나의 요소를 넣거나 지우기 위해 기존의 개수만큼 이동하기 때문이다.

아마 기본적인 특징들로 자료구조를 접해본 사람이라면 한 번은 들어본 특징일 것이다.

### 그렇다면 연결 리스트는 무엇일까?

연결 리스트는 각 요소가 다음 노드를 가리키는 포인터를 갖는 비연속 메모리 구조를 말한다.

잘 이해가 안될 수 있어서 풀어서 설명해보겠다.

노드란 하나의 요소이다. 하나의 노드는 연결되어 있는 노드의 위치 정보(포인터)와 그 내용을 가지고 있는 것이다.  비유를 들자면 하나의 사람이 다음 사람이 어디있는지(포인터) 알고도 있고 각자 물건을 하나 들고(저장할 정보) 있다고 생각하면 편하다.

그렇기에 메모리 상에서 연속적일 필요가 없는 것이다. 다음 사람이 어디있는지의 정보를 이미 들고 있기 때문에 우리는 그 주소를 따라 가면 되지 물리적으로 옆에 나열하여 세워놓을 필요가 없는 것이다.

이러한 개념을 이해했다면 당연히 따라오는 특징들은 다음과 같다.

- 노드 삽입, 삭제 시 시간복잡도가 O(1)이다.
- 순차 탐색 시, 임의 인덱스로 접근이 불가능하기 때문에 시간 복잡도가 O(n)이다.
- 런타임 시에 자유롭게 크기를 늘리거나 줄일 수 있다.
- 배열과 달리 추가적인 포인터를 담을 메모리를 사용하기 때문에 메모리 오버헤드가 있다고 할 수 있다.

### 하나씩 파헤쳐보자 왜 삽입, 삭제 시 시간복잡도가 O(1)인 것일까?

아까 말한 사람을 예로 든 것으로 생각해보자. 우리가 빼려고 하는 사람에 대한 정보를 알고 있다면, 단순히 그 사람의 위치 정보를 알고 있는 사람에게 우리가 빼려고 하는 사람 다음의 위치 정보를 알려주면 된다. 그럼 자연스럽게 우리는 빠진 사람에 대한 정보를 찾을 수 없게 된다.

삽입도 마찬가지다. 단순히 하나하나 바꾸는 것이 아닌 추가되는 사람의 위치 정보를 특정 위치의 사람에게 알려주고 추가되는 사람에게 특정 위치의 사람이 알고 있던 정보를 지금 추가되는 사람한테 알려주면 된다.

말이 좀 복잡하긴 하나 그림으로 그려보면서 생각하면 손쉽게 이해할 수 있을 것이라고 생각한다.

그렇기에 그 다음 항목도 우리는 자연스레 이어서 생각할 수 있다. 우리는 찾고자 하는 사람을 지목하기 위해서는 반드시 그 사람의 정보를 알고 있는 사람을 거쳐가야 한다. 그렇게 된다면 결과적으로 맨 앞 사람이 들고 있는 정보에서 부터 시작해야하며 이는 필수이다.

하지만 개발을 해본 사람이라면 이런 생각이 들 수 도 있다.

**개발을 할 때, 연결 리스트라고 들었지만 인덱스로 접근한 적이 있는데요?**

Java 개발자로써 Java를 예를 삼아서 이야기하겠다.

우리가 쓰는 Java에서는 해당 객체의 함수들 중에 인터페이스로 인덱스 접근이 가능한 라이브러리를 제공한다. 즉 내부적으로는 어떻게 돌아가는지 우리는 모르고 사용하였지만, 겉으로만 보았을 때는 저 이야기가 틀린 것이 아니다.

하지만 그 함수가 어떻게 동작하는지를 들여다본다면 우리가 방금 이야기한 방식인 앞에서부터 순차적으로 접근하는 방식으로 접근하는 것을 알 수 있다.

즉, 배열 형식으로 작성되어 있는 함수라면 바로 O(1)로 접근이 가능하겠지만 연결 리스트로 작성되어 있다면 내부적으로는 앞에서부터 찾아가고 있을 것이다.

### 한 단계만 더 들어가보자 - 캐시 친화성

우리가 사용하는 CPU는 캐시 메모리라는 고속 임시 저장소를 가지고 있다. 이 때, 메인 메모리에서 데이터를 한 번에 1바이트씩 가져오는 것이 아닌 여러 바이트(캐시 라인 단위라고 한다)를 한꺼번에 가져온다.

그래서 메모리에서 어떤 데이터를 가져올 때, 그 주변 데이터도 같이 캐시에 들어와서 다음 접근이 빠른데 이러한 정도를 바로 캐시 친화성이라고 한다.

그럼 우리는 메모리가 연속적인지 아닌지에 대해 앞에서 이야기를 나누었다.

생각했을 때 근처에 있는 메모리를 가져온다면 둘 중 어떤 방법이 친화성이 높겠는가? 즉, 주변 메모리에 관련된 정보가 들어있을 확률이 어떤 것이 높겠는가?

당연히 배열이다. 연결 리스트는 비연속적 메모리 구조를 띄고 있다고 했다. 즉 메모리 어디에 저장이 되어있는지가 랜덤이라는 얘기다. 반면에, 배열은 연속된 메모리 구조를 띄고 있기 때문에 옆에 메모리들을 가져온다면 연관성이 높을 확률이 매우 높다.

## 면접에서는 뭐라고 나올까?

일단 글의 제목처럼 배열과 연결 리스트를 비교해서 설명할 수 있어야 할 것이다.

**배열(Array)와 연결 리스트(Linked List)의 차이점은 무엇인가요?**

```
배열은 메모리에 연속적으로 저장되어 있어서 인덱스 접근이 O(1)로 빠릅니다.
하지만 런타임 시에 크기 변경이 불가능하고 중간 삽입, 삭제가 O(n)으로 느립니다.
연결 리스트는 포인터로 노드를 비연속적으로 연결해 삽입, 삭제가 O(1)입니다.
대신 인덱스 접근이 O(n)이고 포인터 오버헤드와 낮은 캐시 효율이 단점입니다.
```

**배열과 연결 리스트의 시간·공간 복잡도를 설명해 보세요**

```
배열은 인덱스 접근이 O(1), 삽입, 삭제가 O(n)이며, 포인터 오버헤드가 없어 공간 효율이 높습니다.
연결 리스트는 접근이 O(n), 삽입, 삭제가 O(1)이고, 포인터를 저장하므로 공간 오버헤드가 큽니다.
배열은 캐시 친화적이라 순차 접근에 유리하고, 연결 리스트는 동적 메모리 할당에 적합합니다.
따라서 사용 목적에 따라 시간, 공간 효율성을 고려해 선택해야 합니다.
```

**단일 연결 리스트에서 뒤에서 k번째 노드를 찾는 방법은?**

```
two-pointer를 사용해 먼저 하나를 k칸 앞서 보낸 뒤, 두 번째 포인터를 함께 이동시키면 뒤 포인터가 뒤에서 k번째 노드를 가리킵니다.
이는 앞 포인터가 끝에 도달할 때, 뒤 포인터는 정확히 k칸 뒤에 있기 때문입니다.
따라서 리스트 전체를 한 번만 순회하면서 O(n)의 시간복잡도와, O(1)의 공간으로 해결할 수 있습니다.
이 방법은 추가 메모리 없이도 효율적으로 뒤에서 k번째 노드를 찾을 수 있습니다.
```

추가 설명을 더하자면 A→B→C→D→E→F→G→null 이라고 할 때 k=3이면 우리가 찾고자 하는건 E이다. 그렇다면 먼저 첫 포인터를 k칸 앞서서, 즉 D에 놓는다.

그런 후 동시에 한칸씩 같이 이동시키면 정확히 k칸 차이가 나기 때문에 앞서 보낸 포인터가 null에 도달하면 그 기준으로 k칸 뒤에 두번째 포인터가 위치하게 된다.

**배열 기반 큐와 연결 리스트 기반 큐의 장단점은?**

```
배열 기반 큐는 인덱스 접근이 빠르고 캐시 효율이 높지만, 크기 제한과 데이터 이동 비용이 단점입니다.
반면 연결 리스트 기반 큐는 크기 제한 없이 동적으로 확장 가능하며 삽입, 삭제가 빠르지만, 포인터 오버헤드와 낮은 캐시 효율이 단점입니다.
배열 큐는 순환 큐로 구현하면 공간 활용도를 높일 수 있습니다.
연결 리스트 큐는 메모리 단편화가 발생할 수 있으므로 상황에 맞게 선택해야 합니다.
```

배열 큐라는 것은 배열을 큐로 활용한다는 것까지는 이해가 될 것이다. 이 때, 순환 큐란 배열의 끝까지 다 쓰면 처음으로 돌아가서 다시 사용한다는 의미이다.

기존의 큐라면 앞에서 빼고 뒤로 넣기 때문에 위치 정보를 두 개 기억하고 있어야 할 것이다.

그렇다면 앞에 빈 공간이 발생할 텐데 이 빈공간을 활용하기 위해 순환시키는 것이다.

즉, 큐의 끝을 가리키는 포인터가 끝에 도달하면 실제 배열의 앞을 가리키게 만들어서 앞에 공간도 채울 수 있게 하는 것이다.

추가적으로 (index+1)%size를 한다면 인덱스를 앞으로 순환시킬 수 있다.

**순환 연결 리스트(Circular Linked List)는 언제 쓰이나요?**

```
순환 연결 리스트는 마지막 노드가 처음 노드를 가리켜 리스트의 끝과 시작이 연결된 구조로, 순환 구조가 필요한 상황에 사용됩니다.
대표적으로 라운드 로빈 스케줄링, 음악 재생 리스트, 게임 턴 처리 등에서 유용합니다.
처음 노드로 되돌아가는 처리를 별도 조건 없이 자연스럽게 할 수 있는 것이 장점입니다.
단, 순환 구조 특성상 무한 루프를 방지하기 위한 종료 조건 설정이 중요합니다.
```

말 그대로 마지막 노드가 null이 아닌 첫 노드를 다시 가리키는 구조를 순환 연결 리스트라고 한다.

라운드 로빈 스케줄링 방식은 여러 프로세스가 동시에 실행을 기다릴 때 CPU 시간을 돌아가면서 공평하게 나눠주는 방식이다. 즉 모든 프로세스가 끝날 때까지 작업이 공평하게 시간이 할당되어 순환구조의 형태를 띈다.

**배열 기반 스택 vs. 연결 리스트 기반 스택, 어느 상황에 유리한가요?**

```
고정된 크기에서 빠른 성능이 필요하다면 배열 기반 스택이 유리합니다.
배열은 연속된 메모리를 사용해 캐시 효율이 좋고, 인덱스 접근이 O(1)로 빠릅니다.
반면 크기 변화가 잦고 동적 확장이 필요하다면 연결 리스트 기반 스택이 적합합니다.
연결 리스트는 메모리를 유동적으로 사용하므로 오버플로우 걱정 없이 삽입, 삭제가 O(1)로 처리합니다.
```

위의 질문들은 다 기본 개념을 기반으로 어느 정도까지 생각해 보았는가를 물어보는 질문이다. 기본 개념을 충실히 이해하고 있고 한번쯤 생각해보았다면 쉽게 말할 수 있을 것이라 생각한다.