스택과 큐는 단순하게 입출 부분에서 차이가 나는 자료구조이다.

스택은 후입선출(Last-In, First-Out, LIFO) 구조이다.

- push : 스택의 맨 위의 요소 삽입
- pop : 스택의 맨 위 요소 제거 및 반환
- peek() : 맨 위 요소 조회
- isEmpty : 비었는지 확인

시간 복잡도는 모든 연산이 O(1)이다.

큐는 선입선출(First-In, First-Out, FIFO) 구조이다.

- enqueue : 큐의 뒤에 요소 삽입
- dequeue : 큐의 앞 요소 제거 및 반환
- peek, front : 앞 요소 조회
- isEmpty : 비었는지 확인

마찬가지로 시간 복잡도는 모든 연산이 O(1)이다.

좀 더 신경 써서 볼 부분은 사용 사례이다.

## 사용 사례

단순한 알고리즘 부터 말한다면

DFS에서는 스택이 BFS에서는 큐가 사용이 된다. DFS에서는 재귀 호출을 하기 때문인데 재귀 호출 시에는 현재 실행 위치를 저장 및 복귀하는 과정에서 스택이 사용된다.

팩토리얼로 예를 들어보자.

```
int factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}
```

이렇게 재귀의 형태로 팩토리얼을 정의해 놓았을 때, factorial(3)을 호출하면

factorial(3) 호출 → 3*factorial(2)

factorial(2) 호출 → 2*factorial(1)

factorial(1) 호출 → return 1

이러한 과정을 거치게 되는데 이 때 함수를 호출할 때마다 스택에 쌓이는 것이다. 반대로 반환할 때마다 스택에서 빠지게 되는 것이다.

다음은 괄호 검사이다. 코드나 수식의 괄호 짝 맞추기에서도 스택이 사용된다. 괄호가 열렸다고 하였을 때, 스택이 쌓이고 닫는 괄호가 나왔을 때, 스택이 pop되는 형태도 짝을 맞출 수 있다.

큐는 BFS 말고도 다음과 같은 사례에 쓰인다.

- 프린터 작업 스케줄링
- 메시지 큐
- 운영체제 작업 스케줄

프린터 작업 스케줄링부터 설명하자면 프린터는 한 번에 하나만 인쇄가 가능해야 하며 먼저 요청한 작업이 먼저 인쇄되어야 하는 FIFO 구조를 지녀야 한다.

또한 메시지 큐 또한 작업 요청 메시지를 큐에 쌓아놓고 먼저 들어온 요청부터 처리하는 것이 메시지 큐의 방식이기에 이도 큐를 사용한다.

마찬가지로 운영체제의 작업 스케줄링에서 CPU는 여러 프로세스를 번갈아 실행해야 하는데 이 때, 라운드 로빈 방식 등은 Queue에 프로세스를 줄 세워서 대시 순서대로 처리한다.

## 그렇다면 면접은?

스택과 큐의 개념은 많이 어렵지 않고 사례도 근처에서 쉽게 찾을 수 있을 정도이다. 그렇기에 가볍게 숙지해 놓으면 대답하기 어렵지 않을 것이다.

**스택(Stack)과 큐(Queue)는 무엇이며, 각각의 사용 사례는 무엇인가요?**

```
스택은 후입선출 구조로, 나중에 들어온 데이터가 먼저 처리됩니다.
반면 큐는 선입선출 구조로 먼저 들어온 데이터가 먼저 처리됩니다.
스택은 함수 호출 스택, 실행 취소 기능 등 주로 되돌리기 작업에서 사용됩니다.
큐는 프린터 작업 대기열, 메시지 큐, 운영체제의 프로세스 스케줄링 등 순차 처리와 비동기 통신에 활용됩니다.
```

**큐를 배열로 구현할 때 순환 큐(Circular Queue) 방식이란?**

```
순환 큐는 배열로 큐를 구현할 때, 배열의 끝에 도달하면 다시 처음으로 돌아가도록 만드는 방식입니다.
이 방식을 사용하면 앞쪽에 남는 빈 공간을 재활용할 수 있어, 배열의 공간 활용률이 높아집니다.
보통 front와 rear 인덱스를 `% 배열 크기`로 나눈 나머지를 이용해 순환을 구현합니다.
이 덕분에 고정 크기의 배열에서도 효율적으로 큐를 운영할 수 있습니다.
```

**스택 오버플로우(Stack Overflow)와 언더플로우(Underflow)가 뭔가요?**

```
스택 오버플로우는 스택의 최대 용량을 초과해 데이터를 추가하려고 할 때 발생하는 오류입니다.
반대로 스택 언더플로우는 비어 있는 스택에서 데이터를 꺼내려 할 때 발생하는 오류입니다.
오버플로우는 재귀 호출이 너무 깊을 때나 무한 재귀에서 자주 발생합니다.
언더플로우는 pop 연산 시 스택이 비어 있는지 체크하지 않을 때 발생합니다.
```

**스택을 이용해 큐를, 또는 큐를 이용해 스택을 구현할 수 있나요?**

```
스택을 두 개 이용하면 큐를, 큐를 두 개 이용하면 스택을 구현할 수 있습니다.
스택 2개를 사용한 큐 구현은 한 스택에 데이터를 넣고, 필요할 때 다른 스택으로 뒤집어 꺼내는 방식입니다.
큐 2개를 사용한 스택 구현은 하나의 큐에 데이터를 넣고, 다른 큐로 앞의 요소들을 이동시켜 마지막 요소만 남기는 방식입니다.
이러한 방식은 각각의 자료구조의 연산 원리를활용해 다른 구조를 흉내 낸 대표적인 알고리즘 문제입니다.  
```

이 부분만 좀만 더 자세히 설명하겠다.

먼저 Queue를 만들기 위해 stack 두 개를 사용하는 것이다.

먼저 스택을 inStack, outStack으로 분리해 2개 둔다.

enqueue같은 경우는 무조건 inStack에 push한다. 그리고 dequeue인 경우에는 outStack이 비어 있으면 inStack을 pop에서 outStack에 push하여 순서를 역순되게 만든 후, outStack에서 pop해서 꺼낸다.

이렇게 되면 큐와 같이 먼저 들어간게 맨 위로 가게 한번 뒤집어 주는 역할을 하므로 Queue와 같은 구현이 된다.

이번에는 queue 2개로 stack을 구현해보자. activeQueue와 helperQueue라고 이름을 붙이고 살펴보자.

먼저 데이터를 넣는 경우에는 새 값을 helperQueue에 넣고 기존 activeQueue에 있는 값을 helper로 전부 옮기자. 그러면 새로운 값이 큐의 가장 앞에 오고 나머지가 위에 있던 순으로 큐에 들어갈 것이다. 그러면 벌써 스택의 순서로 들어가 있는것이 보인다. 이 상태에서 꺼내면 가장 나중에 넣은 값이 맨 앞에 오기 때문에 pop이 성공되는 것이다.

이제 다시 새로운 값을 넣을 때는 helperQueue와 activeQueue의 역할을 바꿔서 수행하면 된다.