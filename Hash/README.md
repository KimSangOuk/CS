해시란 무엇일까?

해시는 데이터를 일정한 규칙에 따라 고정된 크기의 숫자나 문자열로 변환한 값이다. 예를 들면 주민등록번호 같은 느낌의 고유한 값으로 바꾸려고 시도 하는 값인 것이다.

이러한 특정한 규칙으로 데이터를 바꾸는 로직 자체를 해시 함수라고 한다. 그렇다면 해시 테이블은 뭘까? 이렇게 만들어진 해시 값을 인덱스로 사용하여 찾아가는 테이블인 것이다. 이렇게 된다면 우리는 key-value 구조를 이용하여 기존의 배열처럼 빠르게 데이터를 찾을 수 있다.

그렇다면 그냥 배열을 사용하면 되는거 아닌가? 라는 생각에 이를 수 있다. 하지만 Java에서 배열은 인덱스 값으로 숫자만을 가질 수 있다. 하지만 해시 값을 사용한다면 키 값으로 사람 이름이나 주민번호 같은 기존에 인덱스로 사용하지 못했던 복잡한 키들을 사용할 수 있게 된다.

이렇게 된다면 테이블 구조이기 때문에 우리는 O(1)의 시간복잡도로 데이터를 찾아갈 수 있게 된다. 하지만 이런 장점만 존재할까?

## 해시 함수와 충돌

우리는 특정 값을 해시로 변경해서 인덱스로 사용한다고 하였다. 하지만 이러한 과정은 어떻게 될까? 특정 함수를 통해서 문자열이나 특정 값을 특정 인덱스 값으로 변경한 후 매핑하는 것이다. 하지만 만약 다른 값이 똑같은 인덱스를 가리키면 어떻게 되는 걸까?

이러한 경우를 우리는 ‘충돌’이라고 한다. 이런 충돌이 일어날 수록 우리는 계속해서 빈칸을 찾게되고 시간복잡도는 O(1)에서 O(n)으로 증가하게 된다. 이러한 충돌을 해결하기 위해 많은 사람들이 고민을 해왔다. 즉, 같은 값은 최대한 무조건 다른 값을 가지게 하려고 하는 것이다. 하지만 이 방법은 아직까지 100% 완벽하다고 할 수 없고 그렇기 때문에 이러한 충돌을 해결하기 위한 방법들이 나오기 시작했다.

먼저 그 중 하나는 충돌되어서 같은 값을 가리킨다면 연결 리스트를 두어서 연결 시켜서 저장해 두는 방법이다. 이를 Separate Chaining이라고 한다. 같은 값이 계속 될 수록 이러한 체인은 길어지고 그 체인 안에서 사실상 재 검색을 하는 방법인 것이다. 이런 방법은 구현은 말 그대로 단순하나 그렇게 저장해놓은 값을 지우려면 연결 리스트에서 찾아서 제거해야하고 그러려면 오버헤드가 발생한다.

그러면 또 다른 방법은 뭐가 있을까? 충돌이 발생한다면 다른 빈 슬롯을 또 다시 찾아서 저장하는 것이다. 이를 Open Addressing이라고 한다. 이런 대표적인 기법에는 선형 조사, 이차 조사, 이중 해싱 등의 방법이 있다.

선형 조사는 단순하다. 한 칸씩 옆으로 이동하면서 빈 칸을 찾아가는 방법이다. 이를 Linear Probing이라고 한다. 하지만 이러한 방법은 충돌이 지속되면 빈칸을 찾는 횟수가 증가하고 그 만큼 느려진다. 이렇게 해시 테이블에서 충돌이 연속적으로 모이는 현상을 클러스터링이라고 한다.

이러한 클러스터링 현상을 줄이기 위해 생각한 방법이 조금 더 넓은 간격으로 이동해서 찾는 방법이다. 이차 조사(Quadratic Probing)는 선형 조사 방법에서 이동하는 거리를 제곱만큼 증가시키는 방법이다. 예를 들어서 지금 칸이 3번 칸이면 다음에는 3+1^2칸에 그 다음은 3+2^2칸을 찾아가는 것이다. 이렇게 되면 클러스터링이 확실히 줄어들 것이다. 하지만 이 또한 문제점이 있다. 만약에 우리가 설정해둔 테이블 크기가 짝수나 2의 배수라고 하자 그럴 경우, 계속해서 찾아가는 간격이 같을 경우에는 같은 곳을 계속해서 검사만 하고 저장할 위치를 못찾아 무한 루프가 발생할 수 도 있다. 또한 이러면 간격에 따라 안쓰고 있는 공간이 발생할 수 도 있다.

그렇게 해서 생각한 방법이 단순한 건너뛰기 보다는 해시 값을 찾는 과정에서 또 다른 해시 함수로 간격을 정하는 것이다. 말로 설명하기 어려우니 수식을 간단히 보자.

```
index = (hash1(key) + i * hash2(key)) % tableSize
```

이렇게 영향을 주는 요소에 새로운 hash 함수가 포함되는 것이다. 이럴 경우에 충돌 분산의 성능이 매우 향상된다고 한다. 하지만 보다 구현이 복잡해지고 질 좋은 hash2가 필요하다.

## 로드 팩터(Load Factor)?

충돌을 줄이기 위해 중요한 요소 중 하나는 전체 공간의 수에 얼마나 많은 요소가 지금까지 차있냐이다. 즉, 그 비율이 높아진다면 당연히 충돌 확률이 증가하게 될 것이다.

이 때, 현재 저장된 데이터 수 / 테이블 총 크기의 값을 로드 팩터라고 한다. 당연히도 로드 팩터가 높아지면 테이블이 거의 다 차있는 것이기에 충돌 확률은 증가하게 된다.

이런 경우, 해결책은 분모의 크기를 키우면 된다. 즉 테이블 크기를 키우면 된다는 말이다. 이를 리사이즈한다고 한다. 이렇게 리사이즈한 테이블에 모든 key들을 다시 삽입해야 하는데 새로운 크기에 맞춰서 해시 함수에 맞춰 다시 계산해야 한다. 이를 재해싱(Rehashing)이라고 한다.

이렇게 O(n)에 가까워지는 성능을 O(1) 가까이로 다시 높이는 것이다.

## 그렇다면 면접은?

**해시 테이블이란 무엇이며, 내부 동작 원리를 설명해 보세요**

```
해시 테이블은 키를 해시 함수로 변환해 인덱스로 사용하는 자료구조입니다.
주로 빠른 탐색과 삽입이 필요할 때 사용되며, 평균 시간 복잡도는 O(1)입니다.
내부적으로는 배열과 해시 함수, 충돌 처리 기법을 활용합니다.
로드 팩터가 임계치를 넘으면 배열 크기를 키우고 재해싱하여 성능을 유지합니다.
```

**충돌이 발생하면 어떻게 처리하나요? Separate Chaining과 Open Addressing의 차이는?**

```
해시 충돌은 서로 다른 키가 같은 인덱스를 가질 때 발생하며, 두 가지 주요 방식으로 해결합니다.
Separate Chaning은 각 인덱스에 연결 리스트를 두어 중복 저장합니다.
Open Addressing은 빈 공간을 찾아 순차적으로 데이터를 저장하며, 대표적으로 선형 조사법이 있습니다.
체이닝은 공간을 더 쓰지만 삭제가 쉬우며, 오픈 어드레싱은 메모리 접근이 빠르지만 클러스터링 문제가 발생할 수 있습니다.
```

**로드 팩터가 무엇이며, 왜 조절하나요?**

```
로드 팩터는 해시 테이블의 채워진 정도를 나타내는 지표로, 저장된 요소 수 / 테이블 크기로 계산됩니다.
일반적으로 0.75를 넘으면 충돌 가능성이 높아져 탐색 성능이 급격히 저하될 수 있습니다.
이 때 배열의 크기를 두 배로 늘리고 모든 요소를 재해싱하여 성능을 유지합니다.
로드 팩터를 조절하는 이유는 해시 테이블의 탐색/삽입 속도를 일정 수준 이상으로 보장하기 위해서 입니다.
```

**Java의 `HashMap`과 `Hashtable`의 차이점은?**

```
HashMap은 비동기이며 Hashtable은 동기화된 컬렉션입니다.
따라서 HashMap은 단일 스레드 환경에서 빠르고, Hashtable은 멀티스레드 환경에서 안전하지만 느립니다.
또한 HashMap은 null 키와값을 허용하지만, Hashtable은 null 키와 값을 모두 허용하지 않습니다.
요즘은 Hashtable 보다 동기화된 HashMap 대안으로 ConcurrentHashMap을 주로 사용합니다. 
```

여기서 동기화(Synchronized)란 여러 스레드가 동시에 공유 자원에 접근하는 것을 제어하는 기법이다. 즉, 스레드가 공유 자원에 대해 동시에 접근하였을 때, 발생할 수 있는 Race Condition이 일어나는 것을 막기 위해서 사용한다. HashMap의 경우는 여러 스레드가 동시에 값을 넣으면 비동기이기 때문에 데이터 손실, 무한 루프, NullPointerException 등의 버그가 발생할 수 있다.

**해시 함수 설계 시 주의할 점은?**

```
해시 함수는 충돌을 최소화하고, 데이터를 고르게 분산시키는 것이 가장 중요합니다.
입력값이 조금만 달라져도 해시값이 크게 달라지는 민감도가 있어야 합니다.
또한 계산 속도가 빨라야 하고, 해시 테이블 크기와 잘 어울리는 모듈 연산도 고려해야 합니다.
이를 통해 해시 테이블의 성능 저하 없이 효율적인 자료 저장이 가능합니다.
```

## + 다항식 해시?

다항식 해시(Polynomial Rolling Hash)는 문자열을 마치 다항식처럼 보고, 특정 기저(base) 값 P를 이용해 다음과 같이 해시 값을 계산하는 기법이다.

```
H(s) = s₀·P⁰ + s₁·P¹ + s₂·P² + … + sₙ₋₁·Pⁿ⁻¹
```

이렇게 문자열을 다항식 형태로 간주하고 s는 문자 코드를 p는 문자 위치에 따른 가중치 역할을 한다.

위 값을 그대로 쓰면 너무 숫자가 커지기에 큰 소수 M으로 나머지를 취한다.

```
H(s) ≡ (∑₀ⁿ⁻¹ sᵢ·Pᶦ) mod M
```

이때, 알파벳 소문자 26개를 다루는 경우에는 P는 알파벳 수(26)보다 큰 값이면서 곱셈, 나눗셈 연산에서 충돌을 줄이는 소수(Prime)가 좋다. 그래서 프로젝트를 보면 31을 사용하였다.

이 때 M도 소수를 쓰는 이유는 나머지 연산 결과가 소수일 경우 더 고르게 분포된다고 한다. 그래서 충돌 확률이 더 낮아진다고 한다.